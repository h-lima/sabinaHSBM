---
title: "Using sabinaHSBM for link prediction and network reconstruction using Hierarchical Stochastic Block Models"
subtitle: "Example on how to use it to identify missing and spurious links with the full_reconstruction method (with parallelized computation)"
output:
  word_document: default
  pdf_document: default
  html_document:
    toc: true
    toc_float: true
---


The *sabinaHSBM* package provides tools for link prediction and network reconstruction using hierarchical stochastic block models (HSBM). This document demonstrates a simple use for the `full_reconstruction` method, showcasing how it handles missing and spurious links in an incomplete and error-prone network. To enhance computational efficiency during the prediction links step we leverage parallelized computation.

We use the example dataset `dat` included in the package to show key functionalities, including data preparation, link prediction, and network reconstruction. 


# Loading Required Libraries

We begin by loading the required R packages. Missing packages are automatically installed.

```{r setup, message=FALSE, warning=FALSE}
# If the package is not installed, install it from GitHub
# if (!requireNamespace("sabinaHSBM", quietly = TRUE)) {
#   library(remotes)
#   remotes::install_github("h-lima/sabinaHSBM")
# }

# Load the sabinaHSBM package
#library(sabinaHSBM)
#devtools::load_all("/media/sf_UAM_NexTdive/graph_tool/sabinaHSBM/")
devtools::load_all("/media/sf_UAM_NexTdive/graph_tool/sabinaHSBM/")

# If the required packages are not already installed, install them from CRAN
list.of.packages <- c(
  "dplyr",
  "reshape2",
  "reticulate",
  "stringr",
  "tidyr",
  "ROCR",
  "data.table",
  "doParallel",
  "parallel"
)

# Check for missing packages and install them
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[, "Package"])]
if (length(new.packages) > 0) {
  install.packages(new.packages, dependencies = TRUE)
}

# Load the required packages
for (package in list.of.packages) {
  library(package, character.only = TRUE)
}
```


# Load data

The dataset `dat` is a binary bipartite matrix representing a hypothetical species interactions network. Columns and rows correspond to two different types of nodes (e.g., hosts and parasites), and links (values of `1`, in red) represent interaction between them while `0` (in black) represent lack of observed interaction. 

```{r load-data}
# Load the dataset
data(dat, package = "sabinaHSBM")
```

To simulate spurious links and address the `full_reconstruction` method, we add a small number of false positives (`1`) to the matrix. This controlled modification allows us to demonstrate how the method identifies both missing links (unobserved but likely interactions, false negatives) and spurious links (observed but potentially erroneous interactions, false positives).

```{r add-spurious-links, echo=TRUE}
# # Add spurious links
# num_spurious <- 10 # Number of spurious links to add
# 
# set.seed(120)
# 
# for (i in 1:num_spurious) {
#   repeat {
#     random_row <- sample(1:nrow(dat), 1)
#     random_col <- sample(1:ncol(dat), 1)
#     
#     if (dat[random_row, random_col] == 0) {
#       dat[random_row, random_col] <- 1
#       break
#     }
#   }
# }
```

```{r plot-dat, echo=TRUE}
# Plot the original matrix
plot_interaction_matrix(dat, order_mat = FALSE)
```


# Preparing Input data for HSBM

The `hsbm.input` function pre-processes the dataset, creating cross-validation folds and edge lists required for modeling. Here, we use 10-fold cross-validation and the `full_reconstruction` method.

```{r prepare-input}
# Prepare input data
n_folds <- 10       # Number of folds for cross-validation

myInput <- hsbm.input(
  dat,              # Binary bipartite matrix of observed links
  n_folds = n_folds,
  iter = 1000,      # Number of iterations
  wait = 1000,      # Number of ..............
  #add_spurious = TRUE, # Simulate spurious links
  method = "full_reconstruction"  # Method for link prediction
)
```

```{r summary-input}
# Summarizes network characteristics
summary(myInput)
```

```{r plot-dat-spurious, echo=TRUE}
# Plot the matrix with spureous links
plot_interaction_matrix(myInput$data, order_mat = FALSE)
```


# Predict link probabilities

The `hsbm.predict` function applies the HSBM to predict probabilities of all links (observed and unobserved links). This step is crucial to identify spurious and missing links within the data, which are often present in incomplete or error-prone networks. The function works directly with the processed input created by `hsbm.input`.

This step can be computationally intensive when working with large datasets or numerous folds. To improve performance, we use parallelized computation with the `clusterApply` function from the *parallel* package, distributing tasks across multiple cores.  

```{r paarallel-prediction}
# Define the number of cores to use
UseCores <- detectCores() - 2

# Initialize the cluster
cl <- makeCluster(UseCores) 
registerDoParallel(cl)

start_time <- Sys.time()

# Export the input data to the cluster
clusterExport(cl, "myInput")

# Define the list of folds
elist_i <- c(1:n_folds)

# Predict link probabilities
hsbm_out_list <- clusterApply(cl = cl, x = elist_i, function(i) {
  library(reticulate)
  #library(sabinaHSBM)
  devtools::load_all("/media/sf_UAM_NexTdive/graph_tool/sabinaHSBM/")  # ! ! !
  sabinaHSBM::hsbm.predict(myInput, elist_i = i, verbose = TRUE)
})

stopCluster(cl)

end_time <- Sys.time()
cat("Parallel prediction tooks:", end_time - start_time, "mins\n")
```

After running the predictions in parallel, we consolidate the results into a single object:

```{r consolidation}
# Consolidate predictions into a single object
consolidate_hsbm <- function(result) {
  remove_nulls <- function(x) {
    if (is.list(x)) {
      attrs <- attributes(x)
      x <- lapply(x, function(y) if (!is.null(y)) remove_nulls(y) else NULL)
      x <- x[lengths(x) > 0]
      attributes(x) <- attrs
    }
    return(x)
  }

  result <- lapply(result, remove_nulls)

  base_object <- result[1]

  pos_predictions <- which(names(base_object[[1]]) == "predictions")
  pos_min_dl <- which(names(base_object[[1]]) == "min_dl")

  for (i in seq_along(base_object[[1]][[pos_predictions]])) {
    grouped_list <- list()
    for (j in seq_along(result)) {
      grouped_list <- append(grouped_list, result[[j]][[pos_predictions]][[i]])
    }
    base_object[[1]][[pos_predictions]][[i]] <- grouped_list
  }

  grouped_min_dl <- list()
  for (j in seq_along(result)) {
    grouped_min_dl <- append(grouped_min_dl, result[[j]][[pos_min_dl]])
  }
  base_object[[1]][[pos_min_dl]] <- grouped_min_dl

  return(base_object[[1]])
}

myPred <- consolidate_hsbm(hsbm_out_list)
```

Predicted link probabilities and group assignments are stored for each fold. Below, we extract the link probabilities (p) and groups assigments of links for fold 1.

```{r prediction-probs}
# View probabilities for fold 1
probabilities_fold1 <- myPred$predictions$probs[[1]]
head(probabilities_fold1)
```

The group assignments provide the hierarchical clustering structure of nodes for each fold. Let’s extract and examine the group assignments for fold 1:

```{r prediction-groups}
# View the group assignments for fold 1
groups_fold1 <- myPred$predictions$groups[[1]]

# Filtering to include only hosts (in columns)
vnames <- colnames(myPred$data)
groups_fold1 <- groups_fold1 %>% filter(names %in% vnames)

g_cols <- grep("^G", names(groups_fold1))
groups_fold1[g_cols] <- lapply(groups_fold1[g_cols], sort)

print(groups_fold1)
```

Hierarchical group assignments provide insight into how nodes (e.g., hosts) are organized across multiple levels. At the first level (G1), nodes are divided into specific groups, reflecting fine-scale patterns. Moving to higher levels (G2, G3, G4), these groups (or communities) are progressively aggregated, revealing broader patterns and relationships or communities.


# Network Reconstruction

The `hsbm.reconstructed` function generates a reconstructed binary interaction matrix by combining predictions from all folds. The predicted matrix is binarized using a user-specified threshold.  

```{r network-reconstruction}
# Network reconstruction
myReconst <- hsbm.reconstructed(
  myPred,                    # Predictions processed by hsbm.predict
  rm_documented=FALSE,
  na_treatment = "na_to_0", # Treatment of NA values
  threshold = "prc_closest_topright", # Binarization threshold
  new_matrix_method = "ensemble_binary", # Combine fold predictions
  ensemble_threshold = 0.7 # Combine fold predictions
)

cat(paste("The models predicted on average", round(mean(myReconst$tb$pred_held_ones), 1), "% of the held out links. "))
```

This output includes the final averaged probability matrix, the final reconstructed binary matrix, and evaluation metrics. These results highlight the predicted interactions, showcasing the method's ability to detect missing and spurious links effectively. Let’s explore some of the key outputs.

```{r summary-reconstruction}
# View the reconstruction summary and evaluation metrics
summary(myReconst)
```
The summary provides the number of spurious and missing links, as well as key evaluation metrics, such as the retained link recovery rate (RLRR).

```{r tiop-links}
# Visualize the top most likely links
top_links_df <- top_links(myReconst, n = 10)
print(top_links_df)
```

```{r plot-reconstruction}
# Visualize the reconstructed binary matrix
plot_interaction_matrix(myReconst$new_mat, order_mat = FALSE)
```


This document demonstrates the use of the *sabinaHSBM* package for network reconstruction. By applying the full reconstruction method, we showcased how missing and spurious links can be effectively identified and addressed in complex networks.

