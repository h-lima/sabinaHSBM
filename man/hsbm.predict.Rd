% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hsbm_predict.R
\name{hsbm.predict}
\alias{hsbm.predict}
\title{Generate edge/link predictions using Hierarchical Stochastic Block Model (HSBM).}
\usage{
hsbm.predict(
  hsbm_input,
  elist_i = NULL,
  method = "conditional_missing",
  iter = 10000,
  wait = 1000,
  rnd_seed = NULL,
  verbose = TRUE,
  save_blocks = TRUE,
  save_pickle = FALSE,
  save_plots = FALSE,
  n_cores = 1
)
}
\arguments{
\item{hsbm_input}{An object of class \code{hsbm.input} containing the necessary data and configurations for running the HSBM analysis.}

\item{elist_i}{(\emph{optional, default} \code{NULL}) \cr
A \code{numeric} value specifying the index of the edge list (fold) from an \code{hsbm.input}to run predictions on. If \code{NULL}, predictions are run for all edge lists.}

\item{method}{(\emph{optional, default} \code{"conditional_missing"}) \cr
A \code{character} string specifying the method used for the HSBM prediction. Options include \code{"conditional_missing"} and \code{"marginal_all"}.}

\item{iter}{A \code{numeric} value specifying the number of iterations for the HSBM analysis. Default is 10000.}

\item{wait}{A \code{numeric} value specifying the number of iterations needed for MCMC equilibration. Default is 1000.}

\item{rnd_seed}{A \code{numeric} value specifying a seed for the random number generator in graph-tool and numpy python modules. Default is \code{NULL} which does not set a random seed.}

\item{verbose}{(\emph{optional, default} \code{TRUE}) \cr
A \code{logical} value indicating whether to print progress messages during prediction.}

\item{save_blocks}{(\emph{optional, default} \code{TRUE}) \cr
A \code{logical} value indicating whether to save group assignments (blocks) for nodes in the network during the prediction process.}

\item{save_pickle}{(\emph{optional, default} \code{FALSE}) \cr
A \code{logical} value indicating whether to save the model results as Python pickle files for each fold.}

\item{save_plots}{(\emph{optional, default} \code{FALSE}) \cr
A \code{logical} value indicating whether to save a hierarchical edge bundling plot for each fold. When \code{TRUE}, a figure is saved in the working directory as a visual representation of the inferred structure.}

\item{n_cores}{(\emph{optional, default} \code{1}) \cr
A \code{numeric} value indicating the number of CPU cores to use for parallel computation; use \code{parallel::detectCores()} to check the maximum available on your system.}
}
\value{
An object of class \code{hsbm.predict} containing the edge/link predictions and group assignments for the specified edge lists (fold):
\itemize{
\item \code{$data} The binary bipartite \code{matrix} of input data.
\item \code{$folds} A \code{matrix} of cross-validation fold assignments for each held-out edge/link.
\item \code{$method} The method used for the HSBM analysis, as specified by the user.
\item \code{$iter} The number of iterations used to extract link probabilities, as specified by the user. Default is 10000.
\item \code{$wait} The number of iterations needed to test for equilibration in the \code{mcmc_equilibrate} function from \code{graph-tool}.
\item \code{$min_dl} A \code{list} of minimum description length values for each fold.
\item \code{$probs} A \code{list} where each element is a \code{data.frame} with the predicted probabilities for the edges/links in the corresponding edge list (fold), according to the HSBM model. Each \code{data.frame} contains:
\itemize{
\item \code{v1}: The index of the first type of node (rows in the original matrix).
\item \code{v2}: The index of the second type of node (columns in the original matrix).
\item \code{p}: Predicted probabilities of link between the nodes \code{v1} and \code{v2}.
\item \code{v1_names}: Names of the nodes corresponding to \code{v1}, derived from the row names of the original input matrix.
\item \code{v2_names}: Names of the nodes corresponding to \code{v2}, derived from the column names of the original input matrix.
\item \code{edge_type}: The type of edge/link, such as \code{"documented"} for edges/links observed/documented in the original data, \code{"held_out"} for edges/links observed/documented that is retained/masked during cross-validation to assess the model's ability to predict known edges/links, or \code{"reconstructed"} for undocumented edges/links.
}
\item \code{$groups} (if \code{save_blocks = TRUE}) A \code{list} where each element is a \code{data.frame} containing the group assignments for each node in the network for the corresponding edge list (fold). Each \code{data.frame} includes:
\itemize{
\item \code{nodes}: Indices of the nodes in the network.
\item \code{G1, G2, G3, ...}: Group assignments for each node across different hierarchical levels, where each column represents a specific level of the hierarchy and the values indicate the group to which the node belongs.
\item \code{names}: Names of the nodes, derived from the row and column names of the input matrix.
}
}
}
\description{
This function performs predictions based on the HSBM for a specified edge list (or all edge lists) from an \code{hsbm.input} object.
}
\details{
\itemize{
\item The \code{hsbm_input} parameter should be an object of class \code{hsbm.input}, which includes the input data, the cross-validation folds, and corresponding edge lists.
\item The \code{elist_i} parameter allows you to specify a particular edge list to run predictions on. If not specified, predictions are run on all edge lists.
\item The \code{method} parameter determines the link prediction approach:
\describe{
\item{\code{"conditional_missing"}}{
Computes conditional probabilities for each unobserved/undocumented edges/links (\code{0s}), given the inferred block structure.
The probability is computed as: \eqn{p_{ij} = \frac{1}{N} \sum_{k=1}^{N} P(A_{ij} = 1 \mid b^{(k)})}, where \eqn{b^{(k)}} is the block partition sampled at iteration \eqn{k}.
This method is particularly useful for identifying missing linksâ€”unobserved links that are likely to exist in partially incomplete networks.
}
\item{\code{"marginal_all"}}{
Estimates the marginal posterior probabilities for each links (\code{0s} and \code{1s}), by averaging over sampled network configurations.
The probability is given by: \eqn{p_{ij} = \frac{1}{N} \sum_{k=1}^{N} A_{ij}^{(k)}}, where \eqn{A_{ij}^{(k)} = 1} if the link is present in sample \eqn{k}, and \eqn{0} otherwise.
This method allows identifying both missing links (unobserved/undocumented edges/links likely to exist) and potentially spurious links (observed/documented edges/links that might be erroneous). It is suitable for networks that may contain errors or require a more comprehensive assessment of link validity.
}
}
\item The \code{save_blocks} parameter determines whether group assignments (blocks) for nodes are saved during prediction. Set this to \code{FALSE} to skip saving block information.
\item The \code{save_pickle} parameter, when \code{TRUE}, saves the model results as Python pickle file. Files are saved in the working directory named as \code{hsbm_res_fold<i>.pkl}, where \code{i} corresponds to the fold index. The pickle object is a dictionary with 5 elements. enum..... #@@
\item If \code{save_plots = TRUE}, hierarchical edge bundling plots are saved in the working directory as PDF files named \code{hsbm_plot_foldi.pdf}, where \code{i} refers to the fold index.
}
}
\examples{
## Not run:
# Example workflow to generate `myInput`:
data(dat, package = "sabinaHSBM")

# Prepare input for HSBM
myInput <- hsbm.input(data = dat, 
                      n_folds = 10)
## End(Not run)

# Load example HSBM predicted results
data(myInput, package = "sabinaHSBM")

myPred <- hsbm.predict(hsbm_input = myInput,
                      method = "conditional_missing",
                      iter = 1000,
                      wait=1000)

# View link probabilities of fold 1
myPred$probs[[1]]

# View groups of fold 1
myPred$groups[[1]]

}
\seealso{
\code{\link{hsbm.input}}
}
